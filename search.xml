<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[图解TCP和Https]]></title>
    <url>%2F2018%2F07%2F05%2F%E5%9B%BE%E8%A7%A3TCP%E5%92%8CHttps%2F</url>
    <content type="text"><![CDATA[图解TCP和Https 图解TCP TCP 三次握手 Item 1 点击显示 Item 1 Item 2 点击显示 Item 2 TCP 数据传输 TCP 四次挥手 图解HTTPS Http2GitHub Pages]]></content>
      <categories>
        <category>协议</category>
      </categories>
      <tags>
        <tag>Tcp,Https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Parcel——快速、零配置的Web应用程序打包器]]></title>
    <url>%2F2018%2F07%2F03%2FParcel%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E3%80%81%E9%9B%B6%E9%85%8D%E7%BD%AE%E7%9A%84Web%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%93%E5%8C%85%E5%99%A8%2F</url>
    <content type="text"><![CDATA[快速、零配置的 Web 应用程序打包器 特点 [x] 极速打包时间 [x] 打包所有的资源 [x] 自动转换 [x] 零配置代码分拆 [x] 热模块替换 [x] 友好的错误日志 https://blog.csdn.net/u012125579/article/details/79172886https://www.cnblogs.com/linxin/p/8142639.html]]></content>
      <categories>
        <category>打包构建</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反击爬虫，前端工程师的脑洞可以有多大？]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%8F%8D%E5%87%BB%E7%88%AC%E8%99%AB%EF%BC%8C%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%84%91%E6%B4%9E%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E5%A4%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1、前言对于一张网页，我们往往希望它是结构良好，内容清晰的，这样搜索引擎才能准确地认知它。而反过来，又有一些情景，我们不希望内容能被轻易获取，比方说电商网站的交易额，教育网站的题目等。因为这些内容，往往是一个产品的生命线，必须做到有效地保护。这就是爬虫与反爬虫这一话题的由来。 2、常见反爬虫策略但是世界上没有一个网站，能做到完美地反爬虫。 如果页面希望能在用户面前正常展示，同时又不给爬虫机会，就必须要做到识别真人与机器人。因此工程师们做了各种尝试，这些策略大多采用于后端，也是目前比较常规单有效的手段，比如： User-Agent + Referer检测账号及Cookie验证验证码IP限制频次而爬虫是可以无限逼近于真人的，比如： chrome headless或phantomjs来模拟浏览器环境tesseract识别验证码代理IP淘宝就能买到所以我们说，100%的反爬虫策略？不存在的。更多的是体力活，是个难易程度的问题。 不过作为前端工程师，我们可以增加一下游戏难度，设计出一些很(sang)有(xin)意(bing)思(kuang)的反爬虫策略。 3、前端与反爬虫3.1 FONT-FACE拼凑式例子：猫眼电影 猫眼电影里，对于票房数据，展示的并不是纯粹的数字。页面使用了font-face定义了字符集，并通过unicode去映射展示。也就是说，除去图像识别，必须同时爬取字符集，才能识别出数字。 并且，每次刷新页面，字符集的url都是有变化的，无疑更大难度地增加了爬取成本。 3.2 BACKGROUND拼凑式例子：美团 与font的策略类似，美团里用到的是background拼凑。数字其实是图片，根据不同的background偏移，显示出不同的字符。 并且不同页面，图片的字符排序也是有区别的。不过理论上只需生成0-9与小数点，为何有重复字符就不是很懂。 页面A： 页面B： 3.3 字符穿插式例子：微信公众号文章 某些微信公众号的文章里，穿插了各种迷之字符，并且通过样式把这些字符隐藏掉。这种方式虽然令人震惊…但其实没有太大的识别与过滤难度，甚至可以做得更好，不过也算是一种脑洞吧。 对了，我的手机流量可以找谁报销吗？ 3.4 伪元素隐藏式例子：汽车之家 汽车之家里，把关键的厂商信息，做到了伪元素的content里。这也是一种思路：爬取网页，必须得解析css，需要拿到伪元素的content，这就提升了爬虫的难度。 3.5 元素定位覆盖式例子：去哪儿 还有热爱数学的去哪儿，对于一个4位数字的机票价格，先用四个i标签渲染，再用两个b标签去绝对定位偏移量，覆盖故意展示错误的i标签，最后在视觉上形成正确的价格… 这说明爬虫会解析css还不行，还得会做数学题。 3.6 IFRAME异步加载式例子：网易云音乐 网易云音乐页面一打开，html源码里几乎只有一个iframe，并且它的src是空白的：about:blank。接着js开始运行，把整个页面的框架异步塞到了iframe里面… 不过这个方式带来的难度并不大，只是在异步与iframe处理上绕了个弯（或者有其他原因，不完全是基于反爬虫考虑），无论你是用selenium还是phantom，都有API可以拿到iframe里面的content信息。 3.7 字符分割式例子：全网代理IP 在一些展示代理IP信息的页面，对于IP的保护也是大费周折。 他们会先把IP的数字与符号分割成dom节点，再在中间插入迷惑人的数字，如果爬虫不知道这个策略，还会以为自己成功拿到了数值；不过如果爬虫注意到，就很好解决了。 3.8 字符集替换式例子：去哪儿移动侧 同样会欺骗爬虫的还有去哪儿的移动版。 html里明明写的3211，视觉上展示的却是1233。原来他们重新定义了字符集，3与1的顺序刚好调换得来的结果… 源文地址：http://litten.me/2017/07/09/prevent-spiders/]]></content>
      <categories>
        <category>前端安全</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见跨域解决方案]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[什么是跨域？跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 1.) 资源跳转： A链接、重定向、表单提交2.) 资源嵌入： link、script、img、frame等dom标签，还有样式中background:url()、@font-face()等文件外链3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： 1.) Cookie、LocalStorage 和 IndexDB 无法读取2.) DOM 和 Js对象无法获得3.) AJAX 请求不能发送1234567891011121314151617URL 说明 是否允许通信http://www.a.com/a.jshttp://www.a.com/b.js 同一域名下 允许http://www.a.com/lab/a.jshttp://www.a.com/script/b.js 同一域名下不同文件夹 允许http://www.a.com:8000/a.jshttp://www.a.com/b.js 同一域名，不同端口 不允许http://www.a.com/a.jshttps://www.a.com/b.js 同一域名，不同协议 不允许http://www.a.com/a.jshttp://70.32.92.74/b.js 域名和域名对应ip 不允许http://www.a.com/a.jshttp://script.a.com/b.js 主域相同，子域不同 不允许（cookie这种情况下也不允许访问）http://www.a.com/a.jshttp://a.com/b.js 同一域名，不同二级域名（同上） 不允许（cookie这种情况下也不允许访问）http://www.cnblogs.com/a.jshttp://www.a.com/b.js 不同域名 不允许 跨域解决方案 : 1、 通过jsonp跨域2、 document.domain + iframe跨域3、 location.hash + iframe4、 window.name + iframe跨域5、 postMessage跨域6、 跨域资源共享（CORS）7、 nginx代理跨域8、 nodejs中间件代理跨域9、 WebSocket协议跨域 1、JSONP通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 1.）原生实现：12345678910111213&lt;script&gt; var script = document.createElement('script'); script.type = 'text/javascript'; // 传参并指定回调执行函数为onBack script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack'; document.head.appendChild(script); // 回调执行函数 function onBack(res) &#123; alert(JSON.stringify(res)); &#125;&lt;/script&gt; 服务端返回如下（返回时即执行全局函数）：1onBack(&#123;"status": true, "user": "admin"&#125;) 2.）jquery ajax：1234567$.ajax(&#123; url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: "onBack", // 自定义回调函数名 data: &#123;&#125;&#125;); 3.）vue.js：123456this.$http.jsonp('http://www.domain2.com:8080/login', &#123; params: &#123;&#125;, jsonp: 'onBack'&#125;).then((res) =&gt; &#123; console.log(res); &#125;) 后端node.js代码示例：1234567891011121314151617var querystring = require('querystring');var http = require('http');var server = http.createServer();server.on('request', function(req, res) &#123; var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 2、document.domain + iframe跨域此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 1.）父窗口：(www.domain.com/a.html)12345&lt;iframe id="iframe" src="http://child.domain.com/b.html"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'domain.com'; var user = 'admin';&lt;/script&gt; 2.）子窗口：(child.domain.com/b.html)12345&lt;script&gt; document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---&gt; ' + window.parent.user);&lt;/script&gt; 3、location.hash + iframe跨域实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 1.）a.html：(www.domain1.com/a.html)1234567891011121314&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() &#123; iframe.src = iframe.src + '#user=admin'; &#125;, 1000); // 开放给同域c.html的回调方法 function onCallback(res) &#123; alert('data from c.html ---&gt; ' + res); &#125;&lt;/script&gt; 2.）b.html：(www.domain2.com/b.html)123456789&lt;iframe id="iframe" src="http://www.domain1.com/c.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () &#123; iframe.src = iframe.src + location.hash; &#125;;&lt;/script&gt; 3.）c.html：(www.domain1.com/c.html)1234567&lt;script&gt; // 监听b.html传来的hash值 window.onhashchange = function () &#123; // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); &#125;;&lt;/script&gt; 4、window.name + iframe跨域window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(www.domain1.com/a.html)1234567891011121314151617181920212223242526272829303132333435var proxy = function(url, callback) &#123; var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() &#123; if (state === 1) &#123; // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); &#125; else if (state === 0) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; &#125; &#125;; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() &#123; iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); &#125;&#125;;// 请求跨域b页面数据proxy('http://www.domain2.com/b.html', function(data)&#123; alert(data);&#125;); 2.）proxy.html：(www.domain1.com/proxy....中间代理页，与a.html同域，内容为空即可。 3.）b.html：(www.domain2.com/b.html)123&lt;script&gt; window.name = 'This is domain2 data!';&lt;/script&gt; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 5、postMessage跨域postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：a.） 页面和其打开的新窗口的数据传递b.） 多窗口之间消息传递c.） 页面与嵌套的iframe消息传递d.） 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。 1.）a.html：(www.domain1.com/a.html)12345678910111213141516&lt;iframe id="iframe" src="http://www.domain2.com/b.html" style="display:none;"&gt;&lt;/iframe&gt;&lt;script&gt; var iframe = document.getElementById('iframe'); iframe.onload = function() &#123; var data = &#123; name: 'aym' &#125;; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); &#125;; // 接受domain2返回数据 window.addEventListener('message', function(e) &#123; alert('data from domain2 ---&gt; ' + e.data); &#125;, false);&lt;/script&gt; 2.）b.html：(www.domain2.com/b.html)1234567891011121314&lt;script&gt; // 接收domain1的数据 window.addEventListener('message', function(e) &#123; alert('data from domain1 ---&gt; ' + e.data); var data = JSON.parse(e.data); if (data) &#123; data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); &#125; &#125;, false);&lt;/script&gt; 6、跨域资源共享（CORS）普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置。带cookie请求：前后端都需要设置字段，另外需注意：所带cookie为跨域请求接口所在域的cookie，而非当前页。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 1、 前端设置：1.）原生ajax123456789101112131415161718// 前端设置是否带cookiexhr.withCredentials = true;示例代码：var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容// 前端设置是否带cookiexhr.withCredentials = true;xhr.open('post', 'http://www.domain2.com:8080/login', true);xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');xhr.send('user=admin');xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; alert(xhr.responseText); &#125;&#125;; 2.）jQuery ajax12345678$.ajax(&#123; ... xhrFields: &#123; withCredentials: true // 前端设置是否带cookie &#125;, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ...&#125;); 3.）vue框架在vue-resource封装的ajax组件中加入以下代码：1Vue.http.options.credentials = true 2、 服务端设置：若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 1.）Java后台：123456/* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */response.setHeader("Access-Control-Allow-Origin", "http://www.domain1.com"); // 若有端口需写全（协议+域名+端口）response.setHeader("Access-Control-Allow-Credentials", "true"); 2.）Nodejs后台示例：123456789101112131415161718192021222324252627282930var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) &#123; postData += chunk; &#125;); // 数据接收完毕 req.addListener('end', function() &#123; postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取cookie &#125;); res.write(JSON.stringify(postData)); res.end(); &#125;);&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 7、nginx代理跨域1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。123location / &#123; add_header Access-Control-Allow-Origin *;&#125; 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。 实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。 nginx具体配置：123456789101112131415#proxy服务器server &#123; listen 81; server_name www.domain1.com; location / &#123; proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; &#125;&#125; 1.) 前端代码示例：12345678910111213141516171819202122232425262728var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问nginx中的代理服务器xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);xhr.send();2.) Nodejs后台示例：var http = require('http');var server = http.createServer();var qs = require('querystring');server.on('request', function(req, res) &#123; var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, &#123; 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 &#125;); res.write(JSON.stringify(params)); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...'); 8、Nodejs中间件代理跨域node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发。 1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 1.）前端代码示例：12345678910111213141516171819202122232425262728293031var xhr = new XMLHttpRequest();// 前端开关：浏览器是否读写cookiexhr.withCredentials = true;// 访问http-proxy-middleware代理服务器xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true);xhr.send();2.）中间件服务器：var express = require('express');var proxy = require('http-proxy-middleware');var app = express();app.use('/', proxy(&#123; // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) &#123; res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); &#125;, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改&#125;));app.listen(3000);console.log('Proxy server is listen at port 3000...'); 3.）Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。 webpack.config.js部分配置：123456789101112131415module.exports = &#123; entry: &#123;&#125;, module: &#123;&#125;, ... devServer: &#123; historyApiFallback: true, proxy: [&#123; context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 &#125;], noInfo: true &#125;&#125; 9、WebSocket协议跨域WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 1.）前端代码：12345678910111213141516171819202122&lt;div&gt;user input：&lt;input type="text"&gt;&lt;/div&gt;&lt;script src="./socket.io.js"&gt;&lt;/script&gt;&lt;script&gt;var socket = io('http://www.domain2.com:8080');// 连接成功处理socket.on('connect', function() &#123; // 监听服务端消息 socket.on('message', function(msg) &#123; console.log('data from server: ---&gt; ' + msg); &#125;); // 监听服务端关闭 socket.on('disconnect', function() &#123; console.log('Server socket has closed.'); &#125;);&#125;);document.getElementsByTagName('input')[0].onblur = function() &#123; socket.send(this.value);&#125;;&lt;/script&gt; 2.）Nodejs socket后台：123456789101112131415161718192021222324252627var http = require('http');var socket = require('socket.io');// 启http服务var server = http.createServer(function(req, res) &#123; res.writeHead(200, &#123; 'Content-type': 'text/html' &#125;); res.end();&#125;);server.listen('8080');console.log('Server is running at port 8080...');// 监听socket连接socket.listen(server).on('connection', function(client) &#123; // 接收信息 client.on('message', function(msg) &#123; client.send('hello：' + msg); console.log('data from client: ---&gt; ' + msg); &#125;); // 断开处理 client.on('disconnect', function() &#123; console.log('Client socket has closed.'); &#125;);&#125;); 源文地址：https://www.cnblogs.com/roam/p/7520433.html]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[合理的使用语义化标莶]]></title>
    <url>%2F2016%2F07%2F10%2F%E5%90%88%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%AD%E4%B9%89%E5%8C%96%E6%A0%87%E8%8E%B6%2F</url>
    <content type="text"><![CDATA[一、不要使用section作为div的替代品人们在标签使用中最常见到的错误之一就是随意将HTML5的section等价于div——具体地说，就是直接用作替代品(用于样式)。在XHTML或者HTML4中，我们常看到这样的代码：123456789101112131415&lt;div id="wrapper"&gt; &lt;div id="header"&gt; &lt;h1&gt;My super duper page&lt;/h1&gt; Header content &lt;/div&gt; &lt;div id="main"&gt; Page content &lt;/div&gt; &lt;div id="secondary"&gt; Secondary content &lt;/div&gt; &lt;div id="footer"&gt; Footer content &lt;/div&gt;&lt;/div&gt; 而现在在HTML5中，会是这样：12345678910111213141516&lt;!-- 请不要复制这些代码！这是错误的！ --&gt;&lt;section id="wrapper"&gt; &lt;header&gt; &lt;h1&gt;My super duper page&lt;/h1&gt; &lt;!-- Header content --&gt; &lt;/header&gt; &lt;section id="main"&gt; &lt;!-- Page content --&gt; &lt;/section&gt; &lt;section id="secondary"&gt; &lt;!-- Secondary content --&gt; &lt;/section&gt; &lt;footer&gt; &lt;!-- Footer content --&gt; &lt;/footer&gt;&lt;/section&gt; 这样使用并不正确： section并不是样式容器 。section元素表示的是内容中用来帮助构建文档概要的语义部分。它应该包含一个头部。如果你想找一个用作页面容器的元素(就像HTML或者XHTML的风格)，那么考虑如Kroc Camen所说，直接把样式写到body元素上吧。如果你仍然需要额外的样式容器，还是继续使用div吧。 基于上述思想，下面才是正确的使用HTML5和一些ARIA roles特性的例子（注意，根据你自己的设计，你也可能需要加入div）123456789101112131415&lt;body&gt;&lt;header&gt; &lt;h1&gt;My super duper page&lt;/h1&gt; &lt;!-- Header content --&gt;&lt;/header&gt;&lt;div role="main"&gt; &lt;!-- Page content --&gt;&lt;/div&gt;&lt;aside role="complementary"&gt; &lt;!-- Secondary content --&gt;&lt;/aside&gt;&lt;footer&gt; &lt;!-- Footer content --&gt;&lt;/footer&gt;&lt;/body&gt; 如果你还是无法确定使用哪种元素，那么我建议你参考HTML5 sectioning content element flowchart 二、只在需要的时候使用header和hgroup写不需要写的标签当然是毫无意义的。不幸的是，我经常看到header和hgroup被无意义的滥用。你可以阅读一下关于header和hgroup元素的两篇文章做一个详细的了解，其中内容我简单总结如下： header元素表示的是一组介绍性或者导航性质的辅助文字，经常用作section的头部 当头部有多层结构时，比如有子头部，副标题，各种标识文字等，使用hgroup将h1-h6元素组合起来作为section的头部header的滥用由于header可以在一个文档中使用多次，可能使得这样代码风格受到欢迎：1234567&lt;!-- 请不要复制这段代码！此处并不需要header --&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;My best blog post&lt;/h1&gt; &lt;/header&gt; &lt;!-- Article content --&gt;&lt;/article&gt; 如果你的header元素只包含一个头部元素，那么丢弃header元素吧。既然article元素已经保证了头部会出现在文档概要中，而header又不能包含多个元素（如上文所定义的），那么为什么要写多余的代码。简单点写成这样就行了： 1234&lt;article&gt; &lt;h1&gt;My best blog post&lt;/h1&gt; &lt;!-- Article content --&gt;&lt;/article&gt; hgroup的错误使用 在headers这个主题上，我也经常看到hgroup的错误使用。有时候不应该同时使用hgroup和header: 如果只有一个子头部 如果hgroup自己就能工作的很好。。。这不废话么 第一个问题一般是这样的：1234567&lt;!-- 请不要复制这段代码!此处不需要hgroup --&gt;&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;My best blog post&lt;/h1&gt; &lt;/hgroup&gt; &lt;p&gt;by Rich Clark&lt;/p&gt;&lt;/header&gt; 此例中，直接拿掉hgroup，让heading果奔吧。 1234&lt;header&gt; &lt;h1&gt;My best blog post&lt;/h1&gt; &lt;p&gt;by Rich Clark&lt;/p&gt;&lt;/header&gt; 第二个问题是另一个不必要的例子： 1234567&lt;!-- 请不要复制这段代码!此处不需要header --&gt;&lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;My company&lt;/h1&gt; &lt;h2&gt;Established 1893&lt;/h2&gt; &lt;/hgroup&gt;&lt;/header&gt; 如果header唯一的子元素是hgroup，那还要header干神马？如果header中没有其他的元素（比如多个hgroup），还是直接拿掉header吧1234&lt;hgroup&gt; &lt;h1&gt;My company&lt;/h1&gt; &lt;h2&gt;Established 1893&lt;/h2&gt;&lt;/hgroup&gt; 关于hgroup更多的例子和解释，请参阅相关文章 3、不要把所有列表式的链接放在nav里随着HTML5引入了30个新元素（截止到原文发布时），我们在构造语义化和结构化的标签时的选择也变得有些不慎重。也就是说，我们不应该滥用超语义化的元素。不幸的是，nav就是这样一个被滥用的例子。nav元素的规范描述如下： nav元素表示页面中链接到其他页面或者本页面其他部分的区块；包含导航连接的区块。 注意：不是所有页面上的链接都需要放在nav元素中——这个元素本意是用作主要的导航区块。举个具体的例子，在footer中经常会有众多的链接，比如服 务条款，主页，版权声明页等等。footer元素自身已经足以应付这些情况，虽然nav元素也可以用在这里，但通常我们认为是不必要的。 关键的词语是“主要的”导航。当然我们可以互相喷上一整天什么叫做“主要的”。而我个人是这样定义的： 主要的导航 站内搜索 二级导航（略有争议） 页面内导航（比如很长的文章）既然并没有绝对的对错，所以根据一个非正式投票以及我自己的解释，以下的情况，不管你放不放，我反正不放在nav中： 分页控制 社交链接（虽然有些社交链接也是主要导航，比如“关于”“收藏”） 博客文章的标签 博客文章的分类 三级导航 过长的footer如果你不确定是否要将一系列的链接放在nav中，问你自己：“它是主要的导航吗？”为了帮助你回答这个问题，考虑以下首要原则： 如果使用section和hx也同样合适，那么不要用nav — Hixie on IRC为了方便访问，你会在某个“快捷跳转”中给这个nav标签加一个链接吗？ 如果这些问题的答案是“不”，那就跟nav鞠个躬，然后独自离开吧。 4、figure元素的常见错误figure以及figcaption的正确使用，确实是难以驾驭。让我们来看看一些常见的错误， 不是所有的图片都是figure 上文中，我曾告诉各位不要写不必要的代码。这个错误也是同样的道理。我看到很多网站把所有的图片都写作figure。看在图片的份上请不要给它加额外的标签了。你只是让你自己蛋疼，而并不能使你的页面内容更清晰。 规范中将figure描述为“一些流动的内容，有时候会有包含于自身的标题说明。一般在文档流中会作为独立的单元引用。”这正是figure的美妙之处——它可以从主内容页移动到sidebar中，而不影响文档流。 这些问题也包含在之前提到的HTML5 element flowchart中。 如果纯粹只是为了呈现的图，也不在文档其他地方引用，那就绝对不是figure。其他视情况而定，但一开始可以问自己：“这个图片是否必须和上下文有关？”如果不是，那可能也不是figure（也许是个aside）。继续：“我可以把它移动到附录中吗？”如果两个问题都符合，则它可能是 figure。Logo并不是figure 进一步的说，logo也不适用于figure。下面是我常见的一些代码片段：123456789&lt;!-- 请不要复制这段代码!这是错的 --&gt;&lt;header&gt; &lt;h1&gt; &lt;figure&gt; &lt;img src="/img/mylogo.png" alt="My company" class="hide" /&gt; &lt;/figure&gt; My company name &lt;/h1&gt;&lt;/header&gt; 123456&lt;!-- 请不要复制这段代码!这也是错的 --&gt;&lt;header&gt; &lt;figure&gt; &lt;img src="/img/mylogo.png" alt="My company" /&gt; &lt;/figure&gt;&lt;/header&gt; 没什么好说的了。这就是很普通的错误。我们可以为logo是否应该是H1标签而互相喷到牛都放完回家了，但这里不是我们讨论的焦点。真正的问题在于figure元素的滥用。figure只应该被引用在文档中，或者被section元素围绕。我想你的logo并不太可能以这样的方式引用吧。很简单，请勿使用figure。你只需要这样做:1234&lt;header&gt; &lt;h1&gt;My company name&lt;/h1&gt; &lt;!-- More stuff in here --&gt;&lt;/header&gt; Figure也不仅仅只是图片 另一个常见的关于figure的误解是它只被图片使用。figure可以是视频，音频，图表，一段引用文字，表格，一段代码，一段散文，以及任何它们或者其他的组合。不要把figure局限于图片。web标准的职责是精确的用标签描述内容。 5、不要使用不必要的type属性这是个常见的问题，但并不是一个错误，我认为我们应该通过最佳实践来避免这种风格。 在HTML5中，script和style元素不再需要type属性。然而这些很可能会被你的CMS自动加上，所以要移除也不是那么的轻松。但如果你是手工编码或者你完全可以控制你的模板的话，那真的没有什么理由再去包含type属性。所有的浏览器都认为脚本是javascript而样式是css样式，你没必要再多此一举了。123&lt;!-- 请不要复制这段代码!它太冗余了! --&gt;&lt;link type="text/css" rel="stylesheet" href="css/styles.css" /&gt;&lt;script type="text/javascript" src="js/scripts" /&gt;&lt;/script&gt; 其实只需要这样写：12&lt;link rel="stylesheet" href="css/styles.css" /&gt;&lt;script src="js/scripts" /&gt;&lt;/script&gt; 甚至指定字符集的代码都可以省略掉。Mark Pilgrim在Dive into HTML5的语义化一章中作出了解释。 6、form属性的错误使用HTML5引入了一些form的新属性，以下是一些使用上的注意事项： 布尔属性 一些多媒体元素和其他元素也具有布尔属性。这里所说的规则也同样适用。 有一些新的form属性是布尔型的，意味着它们只要出现在标签中，就保证了相应的行为已经设置。这些属性包括： autofocus autocomplete required坦白的说，我很少看到这样的。以required为例，常见的是下面这种：1234&lt;!-- 请不要复制这段代码! 这是错的! --&gt;&lt;input type="email" name="email" required="true" /&gt;&lt;!-- 另一个错误的例子 --&gt;&lt;input type="email" name="email" required="1" /&gt; 严格来说，这并没有大碍。浏览器的HTML解析器只要看到required属性出现在标签中，那么它的功能就会被应用。但是如果你反过来写equired=”false”呢？12&lt;!-- 请不要复制这段代码! 这是错的! --&gt;&lt;input type="email" name="email" required="false" /&gt; 解析器仍然会将required属性视为有效并执行相应的行为，尽管你试着告诉它不要去执行了。这显然不是你想要的。 有三种有效的方式去使用布尔属性。（后两种只在xthml中有效） required required=”” required=”required”上述例子的正确写法应该是:1&lt;input type="email" name="email" required /&gt;]]></content>
      <categories>
        <category>html5</category>
      </categories>
      <tags>
        <tag>语义化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的陷阱]]></title>
    <url>%2F2016%2F07%2F09%2FJavaScript%E4%B8%AD%E7%9A%84%E9%99%B7%E9%98%B1%2F</url>
    <content type="text"><![CDATA[由于 JavaScript “弱语言”的性质，使得其在使用过程中异常的宽松灵活，但也极为容易“掉进陷阱”。这些陷进往往隐藏的很深，所以要多加小心。 全局变量JavaScript 通过函数管理作用域。在函数内部声明的变量只在这个函数内部，函数外面不可用。另一方面，全局变量就是在任何函数外面声明的或是未声明直接简单使用的。“未声明直接简单使用”，指的是不用 var 关键字来声明变量。这个我们已经非常清楚，避免造成隐式产生全局变量的方法就是声明变量尽量用 var 关键字。可你以为用了 var 就 ok 了？来看看这个陷进：1234function foo() &#123; var a = b = 0; // body...&#125; 也许你期望得到的是两个局部变量，但 b 却是货真价实的全局变量。why? Because 赋值运算是自右往左的 ，所以这相当于：1234function foo() &#123; var a = (b = 0); // body...&#125; 所以 b 是全局变量。 解决：变量声明，最好一个个来，别搞批发~_~; 变量声明先来看陷阱：123456789myName = "global"; function foo() &#123; alert(myName); var myName = "local"; alert(myName);&#125; foo(); 乍看上去，我们预计期望两次 alert 的结果分别为 “global” 与 “local”，但真实的结果是 “undefined” 与 “local”。why? Because 变量在同一作用域（同一函数）中，声明都是被提至作用域顶部先进行解析的 。 所以以上代码片段的执行行为可能就像这样：123456function foo() &#123; var myName; alert(myName); // "undefined" myName = "local"; alert(myName); // "local"&#125; 用另一个陷阱来测试下你是否真的理解了预解析：12345if (!("a" in window)) &#123; var a = 1;&#125; alert(a); a 变量的声明被提前到了代码顶端，此时还未赋值。接下来进入 if 语句，判断条件中 “a” in window 已成立（a 已被声明为全局变量），所以判断语句计算结果为 false，直接就跳出 if 语句了，所以 a 的值为 undefined。12345678var a; // "undefined"console.log("a" in window); // true if (!("a" in window)) &#123; var a = 1; // 不执行&#125; alert(a); // "undefined" 解决：变量声明，最好手动置于作用域顶部，对于无法当下赋值的变量，可采取先声明后赋值的手法。 函数声明 函数声明也是被提前至作用域顶部，先于任何表达式和语句被解析和求值的 12345alert(typeof foo); // "function" function foo() &#123; // body...&#125; 可以对比一下：12345alert(typeof foo); // "undefined" var foo = function () &#123; // body...&#125;; 明白了这个道理的你，是否还会掉入以下的陷阱呢？1234567891011function test() &#123; alert("1");&#125; test(); function test() &#123; alert("2");&#125; test(); 运行以上代码片段，看到的两次弹窗显示的都是 “2”，为什么不是分别为 “1” 和 “2” 呢？很简单，test 的声明先于 test() 被解析，由于后者覆盖前者，所以两次执行的结果都是 “2”。 解决：多数情况下，我用函数表达式来代替函数声明，特别是在一些语句块中。 函数表达式先看命名函数表达式，理所当然，就是它得有名字，例如：123var bar = function foo() &#123; // body...&#125;; 要注意的是：函数名只对其函数内部可见。如以下陷阱：12345var bar = function foo() &#123; foo(); // 正常运行&#125;; foo(); // 出错：ReferenceError 解决：尽量少用命名函数表达式（除了一些递归以及 debug 的用途），切勿将函数名使用于外部。 函数的自执行对于函数表达式，可以通过后面加上 () 自执行，而且可在括号中传递参数，而函数声明不可以。陷阱：12345// (1) 这只是一个分组操作符，不是函数调用！// 所以这里函数未被执行，依旧是个声明function foo(x) &#123; alert(x);&#125;(1); 以下代码片段分别执行都弹窗显示 “1”，因为在 (1) 之前，都为函数表达式，所以这里的 ()非分组操作符，而为运算符，表示调用执行。12345678910111213141516171819202122232425// 标准的匿名函数表达式var bar = function foo(x) &#123; alert(x);&#125;(1); // 前面的 () 将 function 声明转化为了表达式(function foo(x) &#123; alert(x);&#125;)(1); // 整个 () 内为表达式(function foo(x) &#123; alert(x);&#125;(1)); // new 表达式new function foo(x) &#123; alert(x);&#125;(1); // &amp;&amp;, ||, !, +, -, ~ 等操作符（还有逗号），在函数表达式和函数声明上消除歧义// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了true &amp;&amp; function foo(x) &#123; alert(x);&#125;(1); 解决：这个陷阱的关键在于，弄清楚形形色色函数表达式的实质。 循环中的闭包以下演示的是一个常见的陷阱：12345678var links = document.getElementsByTagName("ul")[0].getElementsByTagName("a"); for (var i = 0, l = links.length; i &lt; l; i++) &#123; links[i].onclick = function (e) &#123; e.preventDefault(); alert("You click link #" + i); &#125; &#125; 我们预期当点击第 i 个链接时，得到此序列索引 i 的值，可实际无论点击哪个链接，得到的都是 i 在循环后的最终结果：”5”。 解释一下原因：当 alert 被调用时，for 循环内的匿名函数表达式，保持了对外部变量 i的引用（闭包），此时循环已结束，i 的值被修改为 “5”。 解决：为了得到想要的结果，需要在每次循环中创建变量 i 的拷贝。以下演示正确的做法：12345678910var links = document.getElementsByTagName("ul")[0].getElementsByTagName("a"); for (var i = 0, l = links.length; i &lt; l; i++) &#123; links[i].onclick = (function (index) &#123; return function (e) &#123; e.preventDefault(); alert("You click link #" + index); &#125; &#125;)(i);&#125; 可以看到，(function () { … })() 的形式，就是上文提到的 函数的自执行 ，i 作为参数传给了 index，alert 再次执行时，它就拥有了对 index 的引用，此时这个值是不会被循环改变的。当然，明白了其原理后，你也可以这样写：12345678for (var i = 0, l = links.length; i &lt; l; i++) &#123; (function (index) &#123; links[i].onclick = function (e) &#123; e.preventDefault(); alert("You click link #" + index); &#125; &#125;)(i);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[职场人士如何利用业余时间自我提升]]></title>
    <url>%2F2016%2F07%2F09%2F%E8%81%8C%E5%9C%BA%E4%BA%BA%E5%A3%AB%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8%E4%B8%9A%E4%BD%99%E6%97%B6%E9%97%B4%E8%87%AA%E6%88%91%E6%8F%90%E5%8D%87%2F</url>
    <content type="text"><![CDATA[职场是个靠实力说话的地方，不想被淘汰，就必须想办法持续提升自己的能力，要学会如何做事，如何搞定客户，如何与同事相处，如何拍领导马屁，如何教导下属……这些能力固然可以在工作中获得提升，但若想快人一步，还得学会如何充分利用业余时间进行自我提升。 这其实是三个问题，第一是如何充分利用时间，第二是提升什么，第三是如何提升 。 一、如何充分利用业余时间假设5点半下班，如果安排合理的话，最早6点半，最晚7点，就可以开始自己的“不被打扰的时间”了，一直到晚上11点上床睡觉，至少有4个小时可以利用。这段时间可以拿来做任何想做的事，比如学习、兼职、锻炼身体等等。按以上的安排，大家可以自己算一算自己比别人每年多了多少时间。要达到这种状态其实一点都不难，下面是我的做法。 首先，需要将碎片时间整合为大块时间。主要是从住和吃两方面考虑 。 如果是租房的话（有房的同学当我没说）， 尽量离上班的地方近一点，这样节省下来的除了大量的时间，还有精力 。想想看，白天工作已经累的跟条狗似的，下班再挤一两个小时的车，到家就变成死狗了，完全没有精力做其它的事情。 你说可以利用路上的时间？确实可以，但由于要开车或挤车，相对而言效率会低很多，而且形式受限（基本只能用听的），这些时间都是碎片时间，虽然可以利用，但只适于获取信息。 所以，如果现在租的房子离公司比较远的话，就不要节省那点房租了，搬家吧。我当初为了节省花在交通上的时间就换了房子，房租高了一倍，面积小了很多，环境也差了不少，但相信我，这些都是值得的。 吃的方面，如果想要提升的能力不包括烹饪的话，还是在外解决吧，平时挑上菜快一点的，卫生有保证的餐厅搞定就行了，最多半个小时。有很多朋友对这点非常抵触，认为这对健康不好，我很认同。所以咱们得找好一点的馆子，别整天吃快餐。以广州为例，天河城附近50块已经可以吃到不错的晚餐了，卫生、环境、口味都有保证。 当然在外吃饭永远也赶不上吃住家饭的感觉，现在网上有很多适合单身人士的菜谱，很多都是既快又好吃，有兴趣做饭的朋友们可以尝试。 除了这两方面，还有其它节省时间的方法，而且不仅仅是业余时间。比如，与其花大量的时间下载电子书，不如直接网上下单，不过一顿快餐钱而已；比如，与其跟朋友有一搭没一搭的聊微信，不如直接打个电话嘘寒问暖一次搞定，即亲切又省事。说到这里大家可能已经发现，其实这些手段无非都是 用金钱换时间 。这么做是因为 时间的价值比我们想象的要大的多，钱没有了还可以再赚，时间没有了就真的没有了 。从这个角度看，可以认为“ 自我提升”本质上是一种投资行为，成本是这些“买到的时间”+“购买时间所花费的金钱”+“提升自己所付出的努力 ”，回报就是未来从工作中获得的收益，长远来看，这是非常划算的。时间就是金钱，这绝对是真理，各位同学如果有心的话，不妨计算一下自己每天丢掉了多少钱。 另外， 当我们有了时间的时候，还得想办法让自己聚焦于真正有意义的事情 ，否则就会使好不容易聚集起来的大块时间重新变得碎片化。从以往的经验来看，在当前的环境下，网络是把时间变得碎片化的重要原因。许多人希望通过断网来解决这个问题，但往往很难实施下去，况且在网络时代，没有必要将自己置于完全封闭的环境中。实际上， 我们需要的不是断网，而是养成不被网络（或其他事务）分散注意力的能力 。要知道，网络固然能帮助我们提高效率，但也仅仅是一个能够提高效率的工具而已。坦白讲，我实在想不出到底哪些自我提升的项目是必须要在网络环境中进行的。即便是我当年学习网络技术的时候，都是通过在虚拟机里搭建虚拟网络解决的（好吧，事实是我买不起cisco的设备来做实验），所以啊， 那些“需要上网才能学习”的言论统统是借口 ！我建议大家体验一下不被网络控制的生活，你会发现只需经过几天的适应期，信息焦虑症就会逐渐消失，我们又有心情去思考人生哲理和宇宙的未来了。 接下来，就讨论一下“提升什么”的问题吧。 二、提升哪些方面“自我提升”实际上是个很“自我”的事情，没有好坏对错之分，只有特点的不同。 大家结合自己的实际情况，分析一下工作和生活方面现存的问题，展望一下未来的发展方向，就能大致有一些眉目了 。以普适性来讲，我建议从下面几个方向考虑。 健康 ：这是人在年轻的时候最容易忽视但实际上却是最重要的一件事，君不见无数中年大叔捶胸顿足就是在懊悔这件事。若有人不服，我只问一句：“你病得起吗？” 当前岗位所需的技能 ：先把眼前的事情做好永远是最重要的。销售就去学习怎样沟通，项目经理就去学习项目管理。 升职所需的技能 ：如果不知道，那就观察一下，你的顶头上司都会些什么？如果你觉得他什么都不懂，那就继续好好观察。 为未来发展所储备的技能 ：早一天打算，便多一分轻松，为未来多做一些累积，等待厚积薄发的那一天吧。比如，如果希望未来能够创业，那么就需要了解和练习管理、人力、财务、沟通、行业等方面的知识和技能，这些准备，当然越早开始越好。 无论何时何地都用得到的基本能力 ：这些技能出色了，不管到哪里，无论做什么，都不会太差。比如沟通、办公软件、思维模式、逻辑、学习能力等等。 个人兴趣 ：这个完全是个人喜好，不会对人生轨迹造成很明显的影响（扎克伯格表示不同意—_—!!!）。 以上分类作为参考，优先级由高到低。下面来看看具体实施的办法。 3、如何提升很简单，就是六个字：“ 多学、多做、多想 ”。 多学 我们从一出生就在不停的学习，不过许多人在成年之后就丧失了学习的意愿，永久止步于某个层级，再也不曾窥见更广阔的世界，所以愿意持续学习同时也会学习的人，无疑是幸福的。 学习的方式有很多，最有效的有两个，一个是请教他人，一个是读书 。 请教他人最直接 ，在交流的过程中可以不断的质疑、思考、汲取，是学习效率最高的方式。同事、老师、上司、同行等等一切比我们牛的人都可以是请教的对象。跟牛人交流，经验值跟开了挂一样啊，所以如果有这样的机会，大家一定要好好把握。 读书有个好处，就是范围特别广 。读书的过程，也是与作者进行思想交流的过程，效率虽然不如谈话那么高，但胜在可以交流的人特别多。只需翻开几本书，便可以同时与不同时代、不同种族、不同视点、不同领域的大师们交流，这种体验，只有读书能带给你。 除了这两种，还有许多其它的学习方式，比如听课或者阅读各类文章等等（可参考“学习金字塔”）。总而言之，只要有心，人人都能学习，并且在任何情况下都能学习（所以别再找借口买水果三件套了）。 多做（做事的做） 通过学习，我们可以掌握许多理论知识，但理论与实践相结合才有价值，用理论来指导实践，不仅实践会变得更有效率，而且也能对理论理解的更加深刻和透彻。那具体到提升能力方面，我们要怎么做呢？下面几点tips可供参考： 多做高价值的事务，摒弃那些低价值的事务 ：一个简单判断事务价值的方法就是看其中包含了多少机械的重复性劳动，因为创造性劳动永远是含金量最高的。另一个方法就是看它是否能够直接带来明显的收益，一般可以认为，越是直接的，事务的含金量越高，当然难度也越高。 做的时候尽量“偷懒” ：理论这种伟光正的武器可以帮助我们更聪明的做事，所以别傻傻的闷头干，用你学到的理论知识来提高效率吧。 搞搞新意思 ：有时候，难免有许多重复性劳动是甩不掉的，这个时候，可以考虑搞点创意，这样不仅有机会找到更多解决问题的办法，也能让自己不无聊。 要做就做好 ：其实就是大前研一强调的专业精神。如果凡事凑合的话，根本就是浪费时间，无法得到任何能力上的提高。 多想 学而不思则罔，所以我们得多思考，而且还得能独立思考，这样才能有效的将理论应用在实践中。思考其实是很有乐趣的，会上瘾，特别是当你了解很多思维方法之后，运用各种方法和工具去分析一个问题，这时候不仅会有解决问题的成就感，也会产生一种智力上的优越感。 思考本质上是一个提高信息利用率的手段 ，同样看一本书，大家接受的信息量是一样的，但有人看完就算了，有人写了读书笔记，有人写了观点剖析，每个人最终的收获肯定不一样，区别就在于思考的深度不同导致对信息的利用率也不同。 思考的话题太大了，简直无从谈起，这里只能勉强凑几个tips。 凡事多想想“为什么” ：大多数真实的问题都藏在一连串的“为什么”里面，通常只要找准了问题就很容易找到解决方案了。 多想想未来 ：如果能够站在历史的角度思考问题，就有助于我们在更高的地方俯视人生。 尽量将思考进行输出 ：比如在知乎回答问题、写文章、讲给别人听等等，这才是训练思考能力的最好方法，否则只能称之为灵光一闪，闪完了就忘了。 以上就是如何充分利用业余时间提升能力的方法，如果上面所说的状态能坚持一段时间的话，就会变成一种习惯，它会驱使着我们去行动，让“提升自我”就变成一个内化的、隐含的目标。最后再次重申， 不要纠结细节和完美的规划，重点在于是否开始了行动，即便每天只能抽出十分钟，那就从这十分钟开始吧 。]]></content>
      <categories>
        <category>职业规划</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[flex自适应截取]]></title>
    <url>%2F2016%2F07%2F04%2Fflex%E8%87%AA%E9%80%82%E5%BA%94%E6%88%AA%E5%8F%96%2F</url>
    <content type="text"><![CDATA[随着移动智能设备的越发普及，智能设备的软硬件也是炉火纯青，我们在做H5页面的时候，通常都会首选display:flex弹性模盒来布局，float基本抛之脑后。flex给我们带来好处的同时，也带来不少坑。最近在做项目时碰到页面效果如下（两个文字都要根据设备不同宽度做自就适应截取）： CSS1234567891011121314151617/* 弹性伸缩布局 */.flex &#123; display: -webkit-box; display: -webkit-flex; display: flex;&#125;.flex-1 &#123; -webkit-box-flex: 1; -webkit-flex: 1; flex: 1;&#125;/* 截取省略 */.ellipsis &#123; text-overflow: ellipsis; white-space: nowrap; overflow: hidden;&#125; HTML 场景一1234&lt;div class="flex"&gt; &lt;h2 class="ellipsis"&gt;主标题主标题主标题主标题主标题主标题主标题&lt;/h2&gt; &lt;p class="ellipsis"&gt;辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息&lt;/p&gt;&lt;/div&gt; HTML 场景二1234567&lt;div class="flex"&gt; &lt;img src="//image.huigoumai.com/20150327478d60ea86997338f3e45fa79a5bd4ad?imageView2/2/w/486/format/webp" width="100" height="100" alt="" /&gt; &lt;div class="flex flex-1"&gt; &lt;h2 class="ellipsis"&gt;主标题主标题主标题主标题主标题主标题主标题&lt;/h2&gt; &lt;p class="ellipsis"&gt;辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 场景二的代码效果居然没能实现自适应截取。经过一翻折腾，最终试出来了，需在父元素使用了flex-1的情况下，重复加上截取样式，得知flex-1样式会引响到子元素ellipsis。 1234567&lt;div class="flex"&gt; &lt;img src="//image.huigoumai.com/20150327478d60ea86997338f3e45fa79a5bd4ad?imageView2/2/w/486/format/webp" width="100" height="100" alt="" /&gt; &lt;div class="flex flex-1 ellipsis"&gt; &lt;h2 class="ellipsis"&gt;主标题主标题主标题主标题主标题主标题主标题&lt;/h2&gt; &lt;p class="ellipsis"&gt;辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息辅助信息&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 附上项目实现截图，以及线上demo]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>ellipsis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何快速定位BUG]]></title>
    <url>%2F2016%2F07%2F04%2F%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%92%E5%AE%9A%E4%BD%8DBUG%2F</url>
    <content type="text"><![CDATA[web发展至今我们碰到的 CSS BUG 的问题都会从容应对，网上搜索一下也会有一些解决方案。但时常我们也会碰到复杂的 CSS BUG 问题，所谓“复杂”实质是指触发的条件很复杂，而“BUG” 也并非指一定是浏览器的 BUG 。对于此类问题，我们首先要解决的是如何定位到问题，只有快速的定位到问题，才能更好的解决问题。对于快速定位，个人的经验处理一般如下（基本可以定位到我在工作中遇到的 90% 以上的复杂 CSS BUG 问题）： 1、检查页面的标签是否闭合、嵌套错误不要小看这条，也许折腾了你两天都没有解决的 CSS BUG 问题，却仅仅源于这里。毕竟页面的模板一般都是由开发来嵌套的，而他们很容易犯此类问题。 快捷提示：可以用 IDE 打开文件检查，一般没有闭合的标签，会黄色背景高亮。 2、样式排除法有些复杂的页面也许加载了 N 个外链 CSS 文件，那么逐个删除 CSS 文件，找到 BUG 触发的具体 CSS 文件，缩小锁定的范围。 对于刚才锁定的问题 CSS 样式文件，逐行删除具体的样式定义，定位到具体的触发样式定义，甚至是具体的触发样式属性。 3、模块确认法有时候我们也可以从页面的 HTML 元素出发。删除页面中不同的 HTML 模块，寻找到触发问题的 HTML 模块。 4、检查是否清除浮动其实有不少的 CSS BUG 问题是因为没有清除浮动造成的。养成良好的清除浮动的习惯是必要的，推荐使用 无额外 HTML 标签的清除浮动的方法（尽量避免使用 overflow:hidden;zoom:1 的类似方法来清除浮动，会有太多的限制性）。 5、检查 IE 下是否触发 haslayout很多的 IE 下复杂 CSS BUG 都与 IE 特有的 haslayout 息息相关。熟悉和理解 haslayout 对于处理复杂的 CSS BUG 会事半功倍。推荐阅读 old9 翻译的 《On having layout》（如果无法翻越穿越伟大的 GFW，可阅读 蓝色上的转帖 ） 快捷提示：如果触发了 haslayout，IE 的调试工具 IE Developer Toolbar 中的属性中将会显示 haslayout 值为 -1。 6、边框背景调试法故名思议就是给元素设置显眼的边框或者背景（一般黑色或红色），进行调试。此方法是最常用的调试 CSS BUG 的方法之一，对于复杂 BUG 依旧适用。经济实惠还环保^^ 最后想给大家强调一点的是，养成良好的书写习惯，减少额外标签，尽量语义，符合标准，其实可以为我们减少很多额外的复杂 CSS BUG，更多的时候其实是我们自己给自己制造了麻烦。希望大家远离 BUG ，生活越来越美好。]]></content>
      <categories>
        <category>bug</category>
      </categories>
      <tags>
        <tag>定位</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3模拟微信拆红包]]></title>
    <url>%2F2016%2F07%2F04%2FCSS3%E6%A8%A1%E6%8B%9F%E5%BE%AE%E4%BF%A1%E6%8B%86%E7%BA%A2%E5%8C%85%2F</url>
    <content type="text"><![CDATA[近期项目做活动页面，其中要实现一个类似微信拆红包效果，试着用CSS3实现了红包以及拆红包的动画。 1234567891011121314151617181920212223242526272829&lt;!--微信红包--&gt;&lt;div style="position:fixed;left:0;top:0;right:0;bottom:0;z-index:3;background-color:rgba(0,0,0,.5);"&gt;&lt;article class="redPacketsBox"&gt; &lt;a href="javascript:;" class="closeRp"&gt;×&lt;/a&gt; &lt;!--拆开前--&gt; &lt;div class="rpBefore flex item-center" id="js-rpBefore"&gt; &lt;div&gt; &lt;p&gt;直播间主持人&lt;br /&gt;给你发了一个红包&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;!--拆开后--&gt; &lt;div class="rpAfter" id="js-rpAfter"&gt; &lt;div class="hd flex item-center"&gt; &lt;div class=""&gt; &lt;p&gt;恭喜你获得优惠券&lt;br /&gt;App专享&lt;/p&gt; &lt;p class="hd-yuan"&gt;5元&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="ft"&gt; &lt;button type="button" name="" class="button"&gt;去App使用&lt;/button&gt; &lt;p style="margin:5px 0 10px;"&gt;请使用微信授权登录&lt;/p&gt; &lt;button type="button" name="" class="button"&gt;继续观看鉴定会&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;button type="button" name="" class="bombBox" id="js-bomb"&gt;&lt;span class="bombBox-inner"&gt;拆&lt;/span&gt;&lt;/button&gt; &lt;/div&gt;&lt;/article&gt;&lt;/div&gt; CSS3123456789101112131415161718192021222324252627282930313233.redPacketsBox&#123;position:fixed;left:50%;top:50%;z-index:9;margin:-200px 0 0 -150px;width:300px;min-height:400px;background-color:#EC514C;border-radius:5px; -webkit-animation: redPackets .8s ease-out; animation: redPackets .8s ease-out;&#125;@-webkit-keyframes redPackets &#123; 0% &#123;-webkit-transform: scale(.2);&#125; 50% &#123;-webkit-transform: scale(1);&#125; 80% &#123;-webkit-transform: scale(.8);&#125; 100% &#123;-webkit-transform: scale(1);&#125;&#125;.redPacketsBox .closeRp&#123;position:absolute;left:5px;top:5px;width:18px;height:18px;line-height:18px;text-align:center;color:#D24235;font-size: 22px;text-decoration: none;font-weight: bold;&#125;.redPacketsBox .rpBefore&#123;min-height:240px;padding:20px;background-color:#FA6059;border-bottom: 1px solid #E5443F;color:#f7df95;font-size:22px;text-align:center;line-height:1.5; box-shadow: 0px 1px 0px -1px rgba(0,0,0,0.1); border-radius:10px 10px 50% 50% / 10px 10px 15% 15%;&#125;.redPacketsBox .bombBox&#123;position:absolute;left:50%;top:230px;margin-left:-45px;background-color:#F7DF95;width:90px;height:90px;padding:5px; border:none;outline:none; border-radius:100%; box-shadow: 0 1px 5px 1px rgba(0,0,0,.1);&#125;.redPacketsBox .bombBox-inner&#123;display:block;width:78px;height:78px;line-height:78px;font-size:36px;font-weight:bold;text-align:center;border:1px solid #E9BF6B;border-radius:100%;&#125;.redPacketsBox .rpAfter&#123;display:none;text-align:center;padding:20px;&#125;.redPacketsBox .rpAfter .hd&#123;min-height:260px;line-height:1.5;color:#f7df95;font-size:22px;&#125;.redPacketsBox .rpAfter .ft .button&#123;width: 100%;box-sizing:border-box;height: 34px;font-size:16px;&#125;.redPacketsBox .rpAfter .hd-yuan&#123;font-size:50px;margin-top:20px;&#125;.redPacketsBox .rotateY&#123; -webkit-animation:bomb .6s infinite alternate; animation:bomb .6s infinite alternate;&#125;@-webkit-keyframes bomb &#123; from &#123; -webkit-transform: rotateY(180deg); &#125; to &#123; -webkit-transform: rotateY(360deg); &#125;&#125; Javascript 点击事件1234567891011var _bomb = document.getElementById('js-bomb'), _rpBefore = document.getElementById('js-rpBefore'), _rpAfter = document.getElementById('js-rpAfter');_bomb.onclick = function() &#123; _bomb.className = 'bombBox rotateY'; setTimeout(function() &#123; _bomb.style.display = 'none'; _rpBefore.style.display = 'none'; _rpAfter.style.display = 'block'; &#125;, 2000)&#125; 附上项目实现截图，以及线上demo]]></content>
      <categories>
        <category>CSS3</category>
      </categories>
      <tags>
        <tag>拆红包</tag>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webApp页面构建基础知识]]></title>
    <url>%2F2016%2F07%2F03%2FwebApp%E9%A1%B5%E9%9D%A2%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1、关闭iOS键盘首字母自动大写IOS的机子，默认英文输入法状态下，首字母是自动大写的，有时候挺烦人的。 我们写页面的时候有没有办法把这个自动大写关闭呢？autocapitalize的属性可以实现： 在iOS中，默认情况下键盘是开启首字母大写的功能的，如果业务不想出现首字母大写，可以这样：1&lt;input type="text" autocapitalize="off" /&gt; 2、关闭iOS输入自动修正和英文输入默认自动首字母大写那样，IOS还做了一个功能，默认输入法会开启自动修正输入内容，这样的话，用户经常要操作两次。所以这个功能有方便和不方便之处，如果有些业务不需要这个功能，可以通过前端代码关闭。 如果不需要的话，可以这样：1&lt;input type="text" autocorrect="off" /&gt; 3、禁止文本缩放当移动设备横竖屏切换时，文本的大小会重新计算，进行相应的缩放，当我们不需要这种情况时，可以选择禁止：123html &#123; -webkit-text-size-adjust: 100%;&#125; 需要注意的是，PC端的该属性已经被移除，该属性在移动端要生效，必须设置 `meta viewport”。 4、移动端如何清除输入框内阴影在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：12345input,textarea &#123; border: 0; /* 方法1 */ -webkit-appearance: none; /* 方法2 */&#125; 5、邮箱地址识别在 Android （iOS不会）上，浏览器会自动识别看起来像邮箱地址的字符串，不论有你没有加上邮箱链接，当你在这个字符串上长按，会弹出发邮件的提示。 关闭邮箱地址识别：1&lt;meta name="format-detection" content="email=no" /&gt; 开启邮件发送：1&lt;a mailto:dooyoe@gmail.com"&gt;dooyoe@gmail.com&lt;/a&gt; 6、移动端手机号码识别在 iOS Safari （其他浏览器和Android均不会）上会对那些看起来像是电话号码的数字处理为电话链接，比如： 7位数字，形如：1234567 带括号及加号的数字，形如：(+86)123456789 双连接线的数字，形如：00-00-00111 11位数字，形如：13800138000 可能还有其他类型的数字也会被识别，但在具体的业务场景中，有些时候这是不必须的，所以你可以关闭电话自动识别，然后在需要拨号的地方，开启电话呼出和短信功能。 （1）关闭电话识别：1&lt;meta name="format-detection" content="telephone=no" /&gt; （2）开启电话功能：1&lt;a href="tel:123456"&gt;123456&lt;/a&gt; （3）开启短信功能：1&lt;a href="sms:123456"&gt;123456&lt;/a&gt; 7、快速回弹滚动我们先来看看回弹滚动在手机浏览器发展的历史： 早期的时候，移动端的浏览器都不支持非body元素的滚动条，所以一般都借助 iScroll; Android 3.0/iOS解决了非body元素的滚动问题，但滚动条不可见，同时iOS上只能通过2个手指进行滚动； Android 4.0解决了滚动条不可见及增加了快速回弹滚动效果，不过随后这个特性又被移除； iOS从5.0开始解决了滚动条不可见及增加了快速回弹滚动效果 在iOS上如果你想让一个元素拥有像 Native 的滚动效果，你可以这样做：1234.demo &#123; overflow: auto; /* auto | scroll */ -webkit-overflow-scrolling: touch;&#125; PS：iScroll用过之后感觉不是很好，有一些诡异的bug，这里推荐另外一个Swiper，这个插件集成了滑屏滚动的强大功能（支持3D），而且还有回弹滚动的内置滚动条，官方地址： http://www.swiper.com.cn/ 8、移动端禁止选中内容如果你不想用户可以选中页面中的内容，那么你可以在css中禁掉：123div &#123; -webkit-user-select: none;&#125; 就这么简单，但是目前只支持webkit内核的浏览器。 9、移动端取消touch高亮效果在做移动端页面时，会发现所有a标签在触发点击时或者所有设置了伪类 :active 的元素，默认都会在激活状态时，显示高亮框，如果不想要这个高亮，那么你可以通过css以下方法来禁止：123.demo &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0);&#125; 这个设置，在大部分机子上都是起效果的。但是，移动端三星自带浏览器，点击页面任意a标签时，设置-webkit-tap-highlight-color:rgba(0,0,0,0)还是会有阴影底色，这应该是浏览器强制加上去的，通过代码设置也无法覆盖。 有一种妥协的方法是把页面非真实跳转链接的a标签换成其它标签，可以解决这个问题。 10、如何禁止保存或拷贝图像做移动端H5页面时，经常踩到不少坑，感觉也是时候整理一下移动端开发笔记了，遇到问题能够快速响应，节省开发时间。今天先mark一下在移动端如何禁止保存或拷贝图像： 通常当你在手机或者pad上长按图像 img ，会弹出选项 存储图像 或者 拷贝图像，如果你不想让用户这么操作，那么你可以通过以下方法来禁止：123img &#123; -webkit-touch-callout: none;&#125; PS：需要注意的是，该方法只在 iOS 上有效。]]></content>
      <categories>
        <category>webApp</category>
      </categories>
      <tags>
        <tag>webApp</tag>
      </tags>
  </entry>
</search>
